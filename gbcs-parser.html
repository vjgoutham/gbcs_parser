<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GBCS Message Parser</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<style>
  /* â”€â”€â”€ GP (Great Britain) Official Palette â”€â”€â”€ */
  :root {
    --gp-green:       #00703C;
    --gp-green-dark:  #005a30;
    --gp-green-light: #cce2d8;
    --gp-blue:        #1d70b8;
    --gp-blue-dark:   #003078;
    --gp-blue-light:  #d2e2f1;
    --gp-red:         #d4351c;
    --gp-red-light:   #f6d7d2;
    --gp-yellow:      #ffdd00;
    --gp-yellow-dark: #594d00;
    --gp-yellow-light:#fff7bf;
    --gp-purple:      #4c2c92;
    --gp-purple-light:#dbd5e9;
    --gp-pink:        #912b88;
    --gp-pink-light:  #f7d7ea;
    --gp-orange:      #f47738;
    --gp-orange-light:#fcd6bc;
    --gp-brown:       #b58840;
    --gp-brown-light: #f2e4c0;
    --gp-grey:        #505a5f;
    --gp-grey-dark:   #0b0c0c;
    --gp-grey-mid:    #b1b4b6;
    --gp-grey-light:  #f3f2f1;
    --gp-white:       #ffffff;
    --gp-black:       #0b0c0c;

    --bg:       #0b0c0c;
    --surface:  #1a1c1d;
    --surface2: #252829;
    --border:   #333638;
    --text:     #f3f2f1;
    --text-dim: #b1b4b6;
    --accent:   #00703C;
    --font-sans: 'IBM Plex Sans', sans-serif;
    --font-mono: 'IBM Plex Mono', monospace;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: var(--font-sans);
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* â”€â”€â”€ Header â”€â”€â”€ */
  header {
    background: var(--gp-green-dark);
    border-bottom: 4px solid var(--gp-yellow);
    padding: 0 2rem;
    display: flex;
    align-items: center;
    gap: 1.5rem;
    height: 64px;
    position: sticky;
    top: 0;
    z-index: 100;
  }
  .header-crown {
    font-size: 1.6rem;
    line-height: 1;
  }
  .header-title {
    font-size: 1.15rem;
    font-weight: 700;
    letter-spacing: 0.01em;
    color: var(--gp-white);
  }
  .header-subtitle {
    font-size: 0.75rem;
    color: var(--gp-green-light);
    font-weight: 400;
    margin-left: auto;
    font-family: var(--font-mono);
  }
  .header-badge {
    background: var(--gp-yellow);
    color: var(--gp-yellow-dark);
    font-size: 0.65rem;
    font-weight: 700;
    padding: 2px 8px;
    letter-spacing: 0.08em;
    font-family: var(--font-mono);
  }

  /* â”€â”€â”€ Layout â”€â”€â”€ */
  .layout {
    display: grid;
    grid-template-columns: 400px 1fr;
    flex: 1;
    overflow: hidden;
    height: calc(100vh - 64px);
  }

  /* â”€â”€â”€ Left Panel â”€â”€â”€ */
  .left-panel {
    background: var(--surface);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .panel-header {
    padding: 1rem 1.25rem 0.75rem;
    border-bottom: 1px solid var(--border);
    background: var(--surface2);
  }
  .panel-header h2 {
    font-size: 0.7rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    font-family: var(--font-mono);
  }

  .input-area {
    padding: 1rem 1.25rem;
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    overflow-y: auto;
  }

  .textarea-wrap {
    position: relative;
    flex: 1;
  }
  textarea {
    width: 100%;
    height: 180px;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 2px;
    color: var(--text);
    font-family: var(--font-mono);
    font-size: 0.72rem;
    padding: 0.75rem;
    resize: vertical;
    outline: none;
    line-height: 1.6;
    transition: border-color 0.15s;
  }
  textarea:focus { border-color: var(--gp-green); }
  textarea::placeholder { color: var(--text-dim); opacity: 0.5; }

  .btn-row {
    display: flex;
    gap: 0.5rem;
  }
  .btn {
    flex: 1;
    padding: 0.65rem 1rem;
    font-family: var(--font-sans);
    font-size: 0.85rem;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: all 0.1s;
    letter-spacing: 0.01em;
  }
  .btn-primary {
    background: var(--gp-green);
    color: white;
  }
  .btn-primary:hover { background: var(--gp-green-dark); }
  .btn-secondary {
    background: var(--surface2);
    color: var(--text-dim);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover { border-color: var(--gp-grey-mid); color: var(--text); }

  /* Example Payloads */
  .examples-section {
    padding: 0 1.25rem 0.5rem;
  }
  .examples-label {
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    font-family: var(--font-mono);
    margin-bottom: 0.5rem;
  }
  .example-btns {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
  }
  .example-btn {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 0.45rem 0.75rem;
    text-align: left;
    font-family: var(--font-mono);
    font-size: 0.65rem;
    cursor: pointer;
    transition: all 0.1s;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .example-btn:hover { border-color: var(--gp-green); color: var(--text); }
  .example-dot {
    width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0;
  }

  /* Legend */
  .legend-section {
    border-top: 1px solid var(--border);
    padding: 1rem 1.25rem;
  }
  .legend-title {
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    font-family: var(--font-mono);
    margin-bottom: 0.75rem;
  }
  .legend-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.3rem;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.7rem;
    color: var(--text-dim);
    font-family: var(--font-mono);
  }
  .legend-swatch {
    width: 10px; height: 10px; flex-shrink: 0; border-radius: 1px;
  }

  /* â”€â”€â”€ Right Panel â”€â”€â”€ */
  .right-panel {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background: var(--bg);
  }

  .results-header {
    padding: 0.85rem 1.5rem;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .results-header h2 {
    font-size: 0.7rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    font-family: var(--font-mono);
  }
  .status-badge {
    font-size: 0.65rem;
    font-family: var(--font-mono);
    padding: 2px 8px;
    font-weight: 600;
    display: none;
  }
  .status-badge.ok { background: var(--gp-green-light); color: var(--gp-green-dark); display: inline; }
  .status-badge.error { background: var(--gp-red-light); color: var(--gp-red); display: inline; }

  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
    padding: 0 1.5rem;
    gap: 0;
  }
  .tab {
    padding: 0.6rem 1.2rem;
    font-size: 0.75rem;
    font-weight: 500;
    font-family: var(--font-mono);
    color: var(--text-dim);
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.1s;
    letter-spacing: 0.03em;
  }
  .tab:hover { color: var(--text); }
  .tab.active { color: var(--gp-yellow); border-bottom-color: var(--gp-yellow); }

  .tab-content {
    flex: 1;
    overflow-y: auto;
    padding: 1.25rem 1.5rem;
    display: none;
  }
  .tab-content.active { display: block; }

  /* â”€â”€â”€ Parse Tree â”€â”€â”€ */
  .parse-tree { font-family: var(--font-mono); }

  .tree-node {
    margin-bottom: 2px;
    border-radius: 2px;
    overflow: hidden;
  }
  .tree-row {
    display: grid;
    grid-template-columns: 24px auto 1fr auto auto;
    align-items: center;
    gap: 0;
    min-height: 28px;
    cursor: default;
    transition: filter 0.1s;
  }
  .tree-row:hover { filter: brightness(1.15); }
  .tree-row.clickable { cursor: pointer; }

  .tree-indent { display: flex; align-items: center; justify-content: center; }
  .tree-toggle { color: var(--text-dim); font-size: 0.6rem; }

  .tree-tag {
    padding: 4px 8px 4px 4px;
    font-size: 0.72rem;
    font-weight: 600;
    white-space: nowrap;
  }
  .tree-desc {
    padding: 4px 8px;
    font-size: 0.72rem;
    color: rgba(255,255,255,0.75);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .tree-hex {
    padding: 4px 8px;
    font-size: 0.7rem;
    font-family: var(--font-mono);
    color: var(--text-dim);
    white-space: nowrap;
    font-weight: 400;
  }
  .tree-len {
    padding: 4px 8px 4px 0;
    font-size: 0.65rem;
    color: var(--text-dim);
    white-space: nowrap;
    opacity: 0.6;
  }

  .tree-children { display: block; }
  .tree-children.collapsed { display: none; }
  .child-indent { margin-left: 16px; border-left: 1px solid var(--border); }

  /* â”€â”€â”€ Hex Dump View â”€â”€â”€ */
  .hex-dump {
    font-family: var(--font-mono);
    font-size: 0.72rem;
    line-height: 2;
  }
  .hex-row {
    display: flex;
    gap: 1rem;
    align-items: baseline;
  }
  .hex-offset {
    color: var(--text-dim);
    width: 5ch;
    flex-shrink: 0;
    opacity: 0.5;
  }
  .hex-bytes { flex: 1; display: flex; flex-wrap: wrap; gap: 4px; }
  .hex-byte {
    padding: 1px 3px;
    border-radius: 2px;
    cursor: default;
    transition: filter 0.1s;
  }
  .hex-byte:hover { filter: brightness(1.3); }
  .hex-ascii { color: var(--text-dim); opacity: 0.4; }

  /* â”€â”€â”€ Fields Table â”€â”€â”€ */
  .fields-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.78rem;
    font-family: var(--font-mono);
  }
  .fields-table th {
    text-align: left;
    padding: 0.5rem 0.75rem;
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    border-bottom: 1px solid var(--border);
    position: sticky;
    top: 0;
    background: var(--bg);
  }
  .fields-table td {
    padding: 0.45rem 0.75rem;
    border-bottom: 1px solid rgba(255,255,255,0.04);
    vertical-align: top;
  }
  .fields-table tr:hover td { background: rgba(255,255,255,0.02); }
  .field-name { font-weight: 600; color: var(--text); }
  .field-value { color: var(--gp-green-light); }
  .field-hex { color: var(--text-dim); opacity: 0.7; }
  .field-type { color: var(--gp-blue-light); opacity: 0.8; }

  /* â”€â”€â”€ Summary â”€â”€â”€ */
  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
  }
  .summary-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-left: 3px solid var(--gp-green);
    padding: 0.85rem 1rem;
  }
  .summary-card.info { border-left-color: var(--gp-blue); }
  .summary-card.warn { border-left-color: var(--gp-yellow); }
  .summary-card.error { border-left-color: var(--gp-red); }
  .summary-card.purple { border-left-color: var(--gp-purple); }
  .summary-card.orange { border-left-color: var(--gp-orange); }
  .sc-label {
    font-size: 0.62rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-dim);
    font-family: var(--font-mono);
    margin-bottom: 0.3rem;
  }
  .sc-value {
    font-size: 0.9rem;
    font-weight: 600;
    font-family: var(--font-mono);
    color: var(--text);
    word-break: break-all;
  }
  .sc-sub {
    font-size: 0.65rem;
    color: var(--text-dim);
    font-family: var(--font-mono);
    margin-top: 0.2rem;
  }

  /* â”€â”€â”€ Empty State â”€â”€â”€ */
  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    opacity: 0.35;
    gap: 0.75rem;
  }
  .empty-icon { font-size: 3rem; }
  .empty-text { font-size: 0.85rem; font-family: var(--font-mono); color: var(--text-dim); }

  /* â”€â”€â”€ Error state â”€â”€â”€ */
  .parse-error {
    background: var(--gp-red-light);
    color: var(--gp-red);
    padding: 1rem 1.25rem;
    font-family: var(--font-mono);
    font-size: 0.8rem;
    border-left: 4px solid var(--gp-red);
    margin-bottom: 1rem;
  }

  /* Color classes for segments */
  .c-header    { background: rgba(0,112,60,0.25);  color: #7dd4b0; }
  .c-general   { background: rgba(29,112,184,0.25); color: #7db8e8; }
  .c-mac       { background: rgba(212,53,28,0.25);  color: #f0927f; }
  .c-payload   { background: rgba(76,44,146,0.25);  color: #b9a4e8; }
  .c-routing   { background: rgba(244,119,56,0.25); color: #f8b896; }
  .c-date      { background: rgba(180,136,64,0.25); color: #e8cc82; }
  .c-counter   { background: rgba(145,43,136,0.25); color: #e882dc; }
  .c-security  { background: rgba(0,112,60,0.35);   color: #aef0cc; }
  .c-dlms      { background: rgba(29,112,184,0.35); color: #a8d4f8; }
  .c-ciphered  { background: rgba(76,44,146,0.35);  color: #d4c4fc; }
  .c-tag       { background: rgba(255,221,0,0.12);  color: #e8d060; }
  .c-length    { background: rgba(255,255,255,0.06); color: #b1b4b6; }

  .scrollbar-hidden::-webkit-scrollbar { display: none; }

  /* Responsive */
  @media (max-width: 900px) {
    .layout { grid-template-columns: 1fr; grid-template-rows: auto 1fr; height: auto; }
    .left-panel { border-right: none; border-bottom: 1px solid var(--border); }
  }
</style>
</head>
<body>

<header>
  <span class="header-crown">ðŸ‘‘</span>
  <span class="header-title">GBCS Message Parser</span>
  <span class="header-badge">GB Companion Spec v4.0</span>
  <span class="header-subtitle">Great Britain Smart Metering</span>
</header>

<div class="layout">
  <!-- Left Panel -->
  <div class="left-panel">
    <div class="panel-header">
      <h2>Input Payload</h2>
    </div>
    <div class="input-area">
      <div class="textarea-wrap">
        <textarea id="inputHex" placeholder="Paste GBCS hex message here...&#10;e.g. DD 00 00 00 00 01 09 0C ..."></textarea>
      </div>
      <div class="btn-row">
        <button class="btn btn-primary" onclick="parseGBCS()">â–¶ Parse</button>
        <button class="btn btn-secondary" onclick="clearAll()">âœ• Clear</button>
      </div>
    </div>

    <div class="examples-section">
      <div class="examples-label">Example Payloads</div>
      <div class="example-btns" id="exampleBtns"></div>
    </div>

    <div class="legend-section">
      <div class="legend-title">Field Classification</div>
      <div class="legend-grid">
        <div class="legend-item"><div class="legend-swatch" style="background:#00703c66"></div>Header</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#1d70b866"></div>General Header</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#d4351c66"></div>MAC / Signature</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#4c2c9266"></div>Payload</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#f4773866"></div>Routing</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#b5884066"></div>Date / Time</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#912b8866"></div>Counter</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#ffdd0022"></div>Tag/Type</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#00703c88"></div>Security</div>
        <div class="legend-item"><div class="legend-swatch" style="background:#1d70b888"></div>DLMS</div>
      </div>
    </div>
  </div>

  <!-- Right Panel -->
  <div class="right-panel">
    <div class="results-header">
      <h2>Parse Results</h2>
      <span class="status-badge" id="statusBadge"></span>
    </div>
    <div class="tabs">
      <div class="tab active" onclick="showTab('summary')">Summary</div>
      <div class="tab" onclick="showTab('tree')">Parse Tree</div>
      <div class="tab" onclick="showTab('table')">Fields Table</div>
      <div class="tab" onclick="showTab('hex')">Hex Dump</div>
    </div>

    <div class="tab-content active" id="tab-summary">
      <div class="empty-state" id="emptySummary">
        <div class="empty-icon">â¬¡</div>
        <div class="empty-text">Paste a GBCS hex message and click Parse</div>
      </div>
      <div id="summaryContent" style="display:none"></div>
    </div>

    <div class="tab-content" id="tab-tree">
      <div class="empty-state" id="emptyTree">
        <div class="empty-icon">â¬¡</div>
        <div class="empty-text">No message parsed yet</div>
      </div>
      <div class="parse-tree" id="treeContent"></div>
    </div>

    <div class="tab-content" id="tab-table">
      <div class="empty-state" id="emptyTable">
        <div class="empty-icon">â¬¡</div>
        <div class="empty-text">No message parsed yet</div>
      </div>
      <div id="tableContent" style="display:none">
        <table class="fields-table">
          <thead>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Hex</th>
              <th>Type</th>
              <th>Offset</th>
              <th>Length</th>
            </tr>
          </thead>
          <tbody id="tableBody"></tbody>
        </table>
      </div>
    </div>

    <div class="tab-content" id="tab-hex">
      <div class="empty-state" id="emptyHex">
        <div class="empty-icon">â¬¡</div>
        <div class="empty-text">No message parsed yet</div>
      </div>
      <div class="hex-dump" id="hexContent"></div>
    </div>
  </div>
</div>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GBCS Parser Engine
// Based on GB Companion Specification v4.0
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Message Type codes
const MESSAGE_CODES = {
  0x0001: 'CS01a - CS01b Alert: Billing Data Log',
  0x0002: 'CS02 - Future Dated Firmware Install',
  0x0003: 'CS03 - Read SMETS2 Meter Balances',
  0x0004: 'CS04 - Activate Emergency Credit',
  0x0007: 'CS07 - Read Tariff Data',
  0x0008: 'CS08 - Update Tariff Data',
  0x000A: 'CS10 - Set Meter UTC Time',
  0x000B: 'CS11 - Read Instantaneous Import Registers',
  0x000E: 'CS14 - Read Import Meter Historical Data',
  0x0011: 'CS17 - Read Supply Status',
  0x0012: 'CS18 - Write Supplier Contact Details',
  0x0013: 'CS19 - Write Change of Tenancy Date',
  0x0014: 'CS20 - Read Gas Meter Inventory Data',
  0x0016: 'CS22 - Write Network Parameters',
  0x0017: 'CS23 - Set Valve State (Gas)',
  0x001A: 'CS26 - Read Meter Balance',
  0x001C: 'CS28 - Read Prepayment Transactions Register',
  0x001E: 'CS30 - Update Pre-Payment Configuration',
  0x0020: 'CS32 - Message to ESME',
  0x0021: 'CS33 - Message to GSME',
  0x0040: 'ECS01a - Alert: Device Log',
  0x0042: 'ECS03 - Execute ESME Disable',
  0x0044: 'ECS05 - Read Device Information',
  0x0046: 'ECS07 - Write Device Information',
  0x0048: 'ECS09 - Write Prepayment Mode',
  0x004C: 'ECS13 - Arm HLS Authentication',
  0x004E: 'ECS15 - Set Security Credentials',
  0x0050: 'ECS17 - Set HAN Interface',
  0x0052: 'ECS19 - Read Supply Voltage Profile',
  0x0054: 'ECS21 - Read SMETS2 Meter Events',
  0x0056: 'ECS23 - Close/Open Valve or Switch',
  0x0058: 'ECS25 - Activate/Deactivate Price Signal',
  0x005A: 'ECS26 - Read HAN Price Signal',
  0x005C: 'ECS27a - Send COS',
  0x0060: 'ECS31 - Load Limiting',
  0x0062: 'ECS33 - Block Transfer of SMETS2 Meter Data',
  0x0064: 'ECS35 - Read Instantaneous Register',
  0x0066: 'ECS37 - Read Firmware',
  0x0070: 'GCS01 - CS01a GCS Alert: Billing Data Log',
  0x0072: 'GCS05 - Set Change of Tenancy',
  0x0074: 'GCS07 - Close/Open Gas Valve',
  0x0076: 'GCS13 - Arm HLS Authentication',
  0x0078: 'GCS14 - Set HAN Interface',
  0x007A: 'GCS17 - GCS Read',
  0x007C: 'GCS21 - Set Gas Valve State',
  0x007E: 'GCS23 - Read Gas Meter Inventory Data',
  0x0080: 'GCS33 - Block Transfer of GSME Data',
  0x0090: 'PCS01 - CS01a PPMID Alert: Billing Data Log',
  0x00A0: 'HCS01 - CS01a HHT Alert: Billing Data Log',
  0x00B0: 'CS01b Alert: Remote Party',
  0x00C0: 'DBG01 - Debug Command',
  0x00F0: 'FWD01 - Forwarder',
};

// Business Originator / Target IDs
const ORIGINATOR_TYPES = {
  '0090': 'Supplier',
  '0091': 'Network Operator',
  '0092': 'Access Control Broker',
  '0093': 'Prepayment Interface Device',
  '0095': 'WAN (HAN) Access Provider',
  '0096': 'WAN Provider',
};

// DLMS Data Types
const DLMS_TYPES = {
  0x00: 'null-data',
  0x01: 'boolean',
  0x02: 'bit-string',
  0x03: 'double-long',
  0x04: 'double-long-unsigned',
  0x06: 'long-unsigned',
  0x09: 'octet-string',
  0x0A: 'visible-string',
  0x0C: 'utf8-string',
  0x0D: 'bcd',
  0x0F: 'integer',
  0x10: 'long',
  0x11: 'unsigned',
  0x12: 'long-unsigned',
  0x13: 'compact-array',
  0x14: 'long64',
  0x15: 'long64-unsigned',
  0x16: 'enum',
  0x17: 'float32',
  0x18: 'float64',
  0x19: 'date-time',
  0x1A: 'date',
  0x1B: 'time',
  0x1C: 'dont-care',
  0x01A0: 'structure',
  0x01A2: 'array',
};

// GBCS Grouping/GBT Tags
const GBT_TAG = 0xDD;
const GBT_HEADER_LEN = 10; // simplified

// CRC-16 (CCITT)
function crc16(bytes) {
  let crc = 0xFFFF;
  for (const b of bytes) {
    crc ^= b << 8;
    for (let i = 0; i < 8; i++) {
      if (crc & 0x8000) crc = ((crc << 1) ^ 0x1021) & 0xFFFF;
      else crc = (crc << 1) & 0xFFFF;
    }
  }
  return crc;
}

function toHex(b) { return b.toString(16).padStart(2, '0').toUpperCase(); }
function bytesToHex(arr, sep = ' ') { return Array.from(arr).map(toHex).join(sep); }

function parseHexInput(str) {
  const clean = str.replace(/[^0-9a-fA-F]/g, '');
  if (clean.length % 2 !== 0) throw new Error('Odd number of hex digits');
  const bytes = new Uint8Array(clean.length / 2);
  for (let i = 0; i < clean.length; i += 2) {
    bytes[i / 2] = parseInt(clean.substr(i, 2), 16);
  }
  return bytes;
}

function readUint16BE(bytes, offset) {
  return (bytes[offset] << 8) | bytes[offset + 1];
}
function readUint32BE(bytes, offset) {
  return ((bytes[offset] << 24) | (bytes[offset+1] << 16) | (bytes[offset+2] << 8) | bytes[offset+3]) >>> 0;
}
function readUint64Hex(bytes, offset) {
  return bytesToHex(bytes.slice(offset, offset + 8), '');
}

// â”€â”€â”€ Main Parser â”€â”€â”€
function parseGBCSMessage(bytes) {
  const result = {
    fields: [],
    nodes: [],
    errors: [],
    summary: {},
  };
  let offset = 0;
  const total = bytes.length;

  function field(name, hexVal, parsedVal, type, category, start, len, description) {
    const f = { name, hexVal, parsedVal, type, category, start, len, description };
    result.fields.push(f);
    return f;
  }

  function node(name, category, start, len, children, description) {
    return { name, category, start, len, children: children || [], description };
  }

  try {
    // â”€â”€ GBT / Frame Header â”€â”€
    if (offset >= total) throw new Error('Empty message');

    const firstByte = bytes[offset];

    // Check for GBT (HDLC-like framing) 0xDD start
    if (firstByte === 0xDD) {
      // GBT frame: DD <type> <len2> ...
      const gbtNode = node('GBT Frame Header', 'c-header', offset, 3, [], 'GBCS Grouping/Block Transfer Header');
      field('GBT Tag', toHex(bytes[offset]), '0xDD â€” GBT/GBCS Frame', 'uint8', 'c-tag', offset, 1, 'GBCS frame start sentinel');
      offset++;
      field('GBT Grouping Id', toHex(bytes[offset]), bytes[offset], 'uint8', 'c-header', offset, 1, 'GBT grouping identifier');
      offset++;
      const frameLen = readUint16BE(bytes, offset);
      field('Frame Length', bytesToHex(bytes.slice(offset, offset+2)), frameLen, 'uint16', 'c-length', offset, 2, 'Total length of GBCS message body');
      offset += 2;
      result.summary.hasGBT = true;
    }

    // â”€â”€ General Ciphering Header (DLMS/COSEM) â”€â”€
    // Tag byte 0xDB = general-ciphering
    // Tag byte 0xE0 = general-glo-ciphering
    // Tag byte 0xE2 = general-ded-ciphering
    const cipherTags = { 0xDB: 'general-ciphering', 0xE0: 'general-glo-ciphering', 0xE2: 'general-ded-ciphering', 0xC0: 'GlobalCipherRequest', 0xC4: 'GlobalCipherResponse' };

    let isCiphered = false;
    if (offset < total && cipherTags[bytes[offset]]) {
      isCiphered = true;
      const cTag = bytes[offset];
      field('Ciphering Tag', toHex(cTag), cipherTags[cTag], 'uint8', 'c-ciphered', offset, 1, 'DLMS ciphering wrapper tag');
      result.summary.cipheringType = cipherTags[cTag];
      offset++;

      // System title length + system title
      if (offset < total) {
        const sysTitleLen = bytes[offset];
        field('System Title Length', toHex(sysTitleLen), sysTitleLen, 'uint8', 'c-length', offset, 1, 'Length of originator system title');
        offset++;
        if (sysTitleLen > 0 && offset + sysTitleLen <= total) {
          const sysTitle = bytes.slice(offset, offset + sysTitleLen);
          field('System Title (Originator)', bytesToHex(sysTitle), parseSystemTitle(sysTitle), 'octet-string', 'c-routing', offset, sysTitleLen, 'GBCS Originator EUI-64 / System Title');
          result.summary.originatorId = bytesToHex(sysTitle, '');
          offset += sysTitleLen;
        }
      }

      // Length of remaining content
      if (offset < total) {
        const rem = readLength(bytes, offset);
        field('Content Length', bytesToHex(bytes.slice(offset, offset + rem.bytesRead)), rem.value, 'uint', 'c-length', offset, rem.bytesRead, 'Length of ciphered content');
        offset += rem.bytesRead;
      }

      // Security control byte
      if (offset < total) {
        const sc = bytes[offset];
        const scDesc = parseSecurityControl(sc);
        field('Security Control Byte', toHex(sc), scDesc.label, 'uint8', 'c-security', offset, 1, scDesc.desc);
        result.summary.securitySuite = scDesc.suite;
        result.summary.securityPolicy = scDesc.policy;
        offset++;
      }

      // Invocation counter (frame counter)
      if (offset + 4 <= total) {
        const ic = readUint32BE(bytes, offset);
        field('Invocation Counter', bytesToHex(bytes.slice(offset, offset+4)), ic, 'uint32', 'c-counter', offset, 4, 'Frame counter / sequence number');
        result.summary.invocationCounter = ic;
        offset += 4;
      }
    }

    // â”€â”€ GBCS General Header â”€â”€
    // If not ciphered, check for GBCS general header structure
    // The GBCS general header starts with transaction id

    // Try to detect General Header block (length-prefixed)
    // In GBCS, after ciphering wrapper comes the plaintext or ciphered block
    // We will parse as much as we can from the remaining bytes

    const remainingStart = offset;
    const remaining = bytes.slice(offset);

    if (!isCiphered && remaining.length > 0) {
      // Try parse as plain GBCS general header
      parseGeneralHeader(bytes, offset, total, field, result);
    } else if (isCiphered && remaining.length > 0) {
      // Parse ciphered payload bytes (as ciphertext block)
      const cipherLen = Math.min(remaining.length - 12, remaining.length); // minus GCM tag
      const gcmTagLen = 12;
      if (remaining.length > gcmTagLen) {
        const cipherData = bytes.slice(offset, total - gcmTagLen);
        field('Ciphered Payload', bytesToHex(cipherData.slice(0, Math.min(cipherData.length, 32))) + (cipherData.length > 32 ? '...' : ''), `${cipherData.length} bytes`, 'octet-string', 'c-ciphered', offset, cipherData.length, 'Encrypted GBCS payload (AES-GCM)');
        result.summary.payloadLength = cipherData.length;
        offset = total - gcmTagLen;

        const gcmTag = bytes.slice(offset, total);
        field('GCM Authentication Tag', bytesToHex(gcmTag), 'AES-128-GCM MAC tag (12 bytes)', 'octet-string', 'c-mac', offset, gcmTagLen, 'AES-GCM authentication tag for integrity verification');
        result.summary.hasGCMTag = true;
        offset = total;
      } else {
        field('Payload (short)', bytesToHex(remaining), `${remaining.length} bytes`, 'octet-string', 'c-ciphered', offset, remaining.length, 'Ciphered content');
        offset = total;
      }
    }

    // If there's still data left and nothing was parsed as ciphered, try GBCS plain
    if (offset < total && isCiphered) {
      // already handled above
    } else if (!isCiphered && offset === remainingStart) {
      // Fallback: raw hex
      parseRawBytes(bytes, offset, total, field);
    }

  } catch (e) {
    result.errors.push(e.message);
  }

  // Build tree from fields
  result.nodes = buildTree(result.fields);
  return result;
}

function parseGeneralHeader(bytes, offset, total, field, result) {
  // General header: transaction-id (tag 0x09, len, data)
  // Originator-system-title
  // Recipient-system-title
  // date-time
  // other-info
  // payload
  // MAC

  let o = offset;

  // Try to read transaction id (DLMS octet-string)
  if (o + 2 <= total && bytes[o] === 0x09) {
    const len = bytes[o + 1];
    if (o + 2 + len <= total) {
      field('Transaction ID Tag', toHex(bytes[o]), '0x09 = octet-string', 'tag', 'c-tag', o, 1, 'DLMS data type tag for transaction identifier');
      o++;
      field('Transaction ID Length', toHex(bytes[o]), len, 'uint8', 'c-length', o, 1, 'Length of transaction identifier');
      o++;
      const tid = bytes.slice(o, o + len);
      field('Transaction ID', bytesToHex(tid), parseTransactionId(tid), 'octet-string', 'c-header', o, len, 'GBCS Transaction Identifier (message code + counter)');
      if (len >= 2) result.summary.messageCode = readUint16BE(tid, 0);
      if (len >= 8) result.summary.transactionCounter = readUint32BE(tid, 4);
      o += len;
    }
  }

  // Originator system title
  if (o + 2 <= total && bytes[o] === 0x09) {
    const len = bytes[o + 1];
    if (o + 2 + len <= total) {
      o++;
      field('Originator Title Length', toHex(bytes[o]), len, 'uint8', 'c-length', o, 1, 'Length of originator system title');
      o++;
      const title = bytes.slice(o, o + len);
      field('Originator System Title', bytesToHex(title), parseSystemTitle(title), 'octet-string', 'c-routing', o, len, 'EUI-64 of message originator device');
      result.summary.originatorId = bytesToHex(title, '');
      o += len;
    }
  }

  // Recipient system title
  if (o + 2 <= total && bytes[o] === 0x09) {
    const len = bytes[o + 1];
    if (o + 2 + len <= total) {
      o++;
      field('Recipient Title Length', toHex(bytes[o]), len, 'uint8', 'c-length', o, 1, 'Length of recipient system title');
      o++;
      const title = bytes.slice(o, o + len);
      field('Recipient System Title', bytesToHex(title), parseSystemTitle(title), 'octet-string', 'c-routing', o, len, 'EUI-64 of message recipient device');
      result.summary.recipientId = bytesToHex(title, '');
      o += len;
    }
  }

  // Date-time
  if (o + 2 <= total && bytes[o] === 0x09) {
    const len = bytes[o + 1];
    if (len === 12 && o + 2 + len <= total) {
      o++;
      o++;
      const dt = bytes.slice(o, o + 12);
      field('Date-Time', bytesToHex(dt), parseDatetime(dt), 'date-time', 'c-date', o, 12, 'GBCS message creation date/time (DLMS date-time format)');
      result.summary.dateTime = parseDatetime(dt);
      o += 12;
    }
  }

  // Other-info (various optional fields)
  // Counter (uint32 big-endian)
  if (o + 4 <= total) {
    const counter = readUint32BE(bytes, o);
    field('Message Counter', bytesToHex(bytes.slice(o, o + 4)), counter, 'uint32', 'c-counter', o, 4, 'GBCS message originator counter');
    result.summary.messageCounter = counter;
    o += 4;
  }

  // Payload: remaining minus last 8 bytes (MAC)
  const macLen = 8;
  if (o + macLen < total) {
    const payloadBytes = bytes.slice(o, total - macLen);
    field('Payload', bytesToHex(payloadBytes.slice(0, Math.min(payloadBytes.length, 64))) + (payloadBytes.length > 64 ? '...' : ''), `${payloadBytes.length} bytes`, 'octet-string', 'c-payload', o, payloadBytes.length, 'GBCS message payload / DLMS data');
    result.summary.payloadLength = payloadBytes.length;

    // Try parse DLMS payload
    parseDLMSPayload(bytes, o, total - macLen, field, result);
    o = total - macLen;
  }

  // MAC / Signature
  if (o < total) {
    const mac = bytes.slice(o, total);
    field('Digital Signature / MAC', bytesToHex(mac), `${mac.length} bytes â€” GBCS message authentication code`, 'octet-string', 'c-mac', o, mac.length, 'ECDSA or GMAC authentication of entire message');
    result.summary.macLength = mac.length;
  }
}

function parseDLMSPayload(bytes, start, end, field, result) {
  let o = start;
  // Skip if too short
  if (end - start < 2) return;

  const tag = bytes[o];
  const tagName = DLMS_TYPES[tag] || DLMS_TYPES[0x0100 | tag];

  if (tag === 0xC0 || tag === 0xC4 || tag === 0xC3 || tag === 0xC5) {
    // DLMS GET-Request / GET-Response
    const serviceNames = { 0xC0: 'GET-Request', 0xC4: 'GET-Response', 0xC3: 'SET-Request', 0xC5: 'SET-Response', 0xC6: 'SET-Response-Normal', 0xC1: 'GET-Request-Normal' };
    field('DLMS Service Tag', toHex(tag), serviceNames[tag] || 'DLMS Service', 'tag', 'c-dlms', o, 1, 'DLMS service/PDU tag');
    result.summary.dlmsService = serviceNames[tag];
    o++;
    field('DLMS Invoke-Id & Priority', toHex(bytes[o]), parsePriority(bytes[o]), 'uint8', 'c-dlms', o, 1, 'DLMS invoke identifier and priority flags');
    o++;
    // More DLMS parsing could follow...
  } else if (tag === 0x61) {
    // general-glo-ciphering inside payload
    field('Inner Ciphering Tag', toHex(tag), 'general-glo-ciphering (0x61)', 'tag', 'c-ciphered', o, 1, 'Inner DLMS ciphering wrapper');
    o++;
  } else if (tagName) {
    field('DLMS Data Type', toHex(tag), tagName, 'tag', 'c-dlms', o, 1, `DLMS data type: ${tagName}`);
  }
}

function parseSecurityControl(sc) {
  const suite = sc & 0x0F;
  const policy = (sc >> 4) & 0x0F;
  const suiteNames = { 0: 'AES-128-GCM', 1: 'AES-256-GCM', 2: 'AES-128-GCM (broadcast)' };
  const policies = [];
  if (policy & 0x01) policies.push('Authenticated');
  if (policy & 0x02) policies.push('Encrypted');
  if (policy & 0x04) policies.push('Broadcast');
  return {
    label: `Suite ${suite} (${suiteNames[suite] || 'Unknown'}) | Policy: ${policies.join(', ') || 'None'}`,
    desc: `Security control byte: suite ${suite}, policy 0x${policy.toString(16)}`,
    suite: suiteNames[suite] || `Suite ${suite}`,
    policy: policies.join(' + ') || 'None',
  };
}

function parseSystemTitle(bytes) {
  if (bytes.length < 3) return bytesToHex(bytes);
  const prefix = String.fromCharCode(...bytes.slice(0, 3).filter(b => b >= 32 && b < 127));
  const serial = bytesToHex(bytes.slice(3), '');
  return `${prefix}:${serial}`;
}

function parseTransactionId(bytes) {
  if (bytes.length < 8) return bytesToHex(bytes);
  const msgCode = readUint16BE(bytes, 0);
  const msgName = MESSAGE_CODES[msgCode] || `Unknown (0x${msgCode.toString(16).toUpperCase().padStart(4,'0')})`;
  const counter = readUint32BE(bytes, 4);
  return `${msgName} | Counter: ${counter}`;
}

function parseDatetime(bytes) {
  if (bytes.length < 12) return bytesToHex(bytes);
  const year = (bytes[0] << 8) | bytes[1];
  const month = bytes[2];
  const day = bytes[3];
  const dow = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat','???'][bytes[4]] || '?';
  const hour = bytes[5];
  const min = bytes[6];
  const sec = bytes[7];
  const hhundredths = bytes[8];
  const deviation = ((bytes[9] << 8) | bytes[10]);
  const clockStatus = bytes[11];
  const pad2 = n => String(n).padStart(2,'0');
  return `${year}-${pad2(month)}-${pad2(day)} ${pad2(hour)}:${pad2(min)}:${pad2(sec)} (UTC${deviation === 0x8000 ? '' : (deviation >= 0 ? '+' : '') + deviation})`;
}

function parsePriority(b) {
  const priority = (b & 0x80) ? 'HIGH' : 'NORMAL';
  const serviceClass = (b & 0x40) ? 'CONFIRMED' : 'UNCONFIRMED';
  const invokeId = b & 0x0F;
  return `Invoke-Id: ${invokeId} | ${priority} priority | ${serviceClass}`;
}

function readLength(bytes, offset) {
  if (bytes[offset] < 0x80) return { value: bytes[offset], bytesRead: 1 };
  const numBytes = bytes[offset] & 0x7F;
  let val = 0;
  for (let i = 0; i < numBytes; i++) val = (val << 8) | bytes[offset + 1 + i];
  return { value: val, bytesRead: 1 + numBytes };
}

function parseRawBytes(bytes, start, end, field) {
  // Best-effort raw parse
  let o = start;
  let idx = 0;
  while (o < end && idx < 50) {
    idx++;
    const b = bytes[o];
    if (DLMS_TYPES[b]) {
      field(`DLMS Tag[${idx}]`, toHex(b), DLMS_TYPES[b], 'tag', 'c-dlms', o, 1, 'DLMS data type tag');
      o++;
    } else {
      field(`Byte[${o}]`, toHex(b), b, 'uint8', 'c-payload', o, 1, 'Raw byte');
      o++;
    }
  }
}

function buildTree(fields) {
  // Flatten for now, future: group by category
  const groups = {};
  for (const f of fields) {
    const cat = f.category;
    if (!groups[cat]) groups[cat] = [];
    groups[cat].push(f);
  }
  return fields; // return flat; tree rendering handles grouping
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UI Logic
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const EXAMPLES = [
  {
    label: 'CS01a Alert (Billing)',
    color: '#00703C',
    hex: 'DD 00 00 58 DB 08 53 4D 45 54 53 32 30 30 31 45 09 00 00 00 00 01 01 00 01 09 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00',
  },
  {
    label: 'ECS05 Read Device Info',
    color: '#1d70b8',
    hex: 'E0 08 53 4D 45 54 53 32 30 30 31 40 00 00 00 2A 20 00 00 00 07 C0 43 00 10 F1 2A 3B 4C 5D 6E 7F 80 91 A2 B3 C4 D5 E6 F7',
  },
  {
    label: 'GCS13 Arm HLS Auth',
    color: '#4c2c92',
    hex: 'DD 00 00 30 DB 08 47 53 4D 45 53 32 30 30 32 09 0A 00 76 00 00 00 01 02 09 08 47 53 4D 45 53 32 30 30 32 09 08 00 00 07 E6 01 01 FE 03 12 00 00 01 AB CD EF 12 34',
  },
  {
    label: 'CS10 Set UTC Time',
    color: '#f47738',
    hex: 'DB 08 44 48 4E 30 30 30 30 31 41 00 00 00 00 31 00 00 00 00 C0 01 C1 00 08 00 01 00 00 00 00 00 09 0C 07 E9 01 15 02 0A 00 00 FF 80 00 00',
  },
];

function populateExamples() {
  const container = document.getElementById('exampleBtns');
  EXAMPLES.forEach((ex, i) => {
    const btn = document.createElement('button');
    btn.className = 'example-btn';
    btn.innerHTML = `<span class="example-dot" style="background:${ex.color}"></span>${ex.label}`;
    btn.onclick = () => {
      document.getElementById('inputHex').value = ex.hex;
      parseGBCS();
    };
    container.appendChild(btn);
  });
}

let parsedResult = null;

function parseGBCS() {
  const input = document.getElementById('inputHex').value.trim();
  if (!input) return;

  let bytes;
  try {
    bytes = parseHexInput(input);
  } catch (e) {
    showError('Invalid hex input: ' + e.message);
    return;
  }

  try {
    parsedResult = parseGBCSMessage(bytes);
    parsedResult.rawBytes = bytes;
    renderResults(parsedResult, bytes);
  } catch (e) {
    showError('Parse error: ' + e.message);
  }
}

function showError(msg) {
  const badge = document.getElementById('statusBadge');
  badge.className = 'status-badge error';
  badge.textContent = 'ERROR';

  document.getElementById('emptySummary').style.display = 'none';
  const sc = document.getElementById('summaryContent');
  sc.style.display = 'block';
  sc.innerHTML = `<div class="parse-error">âš  ${msg}</div>`;
}

function renderResults(result, bytes) {
  const badge = document.getElementById('statusBadge');
  if (result.errors.length === 0) {
    badge.className = 'status-badge ok';
    badge.textContent = `OK â€” ${bytes.length} bytes`;
  } else {
    badge.className = 'status-badge error';
    badge.textContent = `WARN â€” ${result.errors.length} issue(s)`;
  }

  renderSummary(result, bytes);
  renderTree(result, bytes);
  renderTable(result);
  renderHexDump(bytes, result.fields);
}

function renderSummary(result, bytes) {
  document.getElementById('emptySummary').style.display = 'none';
  const sc = document.getElementById('summaryContent');
  sc.style.display = 'block';
  const s = result.summary;

  const msgCode = s.messageCode;
  const msgName = msgCode ? (MESSAGE_CODES[msgCode] || `Unknown 0x${msgCode.toString(16).toUpperCase().padStart(4,'0')}`) : 'Unknown';

  let cards = '';

  const card = (cls, label, value, sub) =>
    `<div class="summary-card ${cls}"><div class="sc-label">${label}</div><div class="sc-value">${value}</div>${sub ? `<div class="sc-sub">${sub}</div>` : ''}</div>`;

  cards += card('', 'Total Length', `${bytes.length} bytes`, `${bytes.length * 8} bits`);
  cards += card('info', 'Ciphering Type', s.cipheringType || 'Plain / Unknown', '');
  if (msgCode) cards += card('purple', 'Message Type', msgName.split(' - ')[0], msgName.split(' - ')[1] || '');
  if (s.originatorId) cards += card('orange', 'Originator ID', s.originatorId.match(/.{1,2}/g).join(' ').toUpperCase().slice(0,24), parseSystemTitle(hexToBytes(s.originatorId)));
  if (s.recipientId) cards += card('info', 'Recipient ID', s.recipientId.match(/.{1,2}/g).join(' ').toUpperCase().slice(0,24), parseSystemTitle(hexToBytes(s.recipientId)));
  if (s.dateTime) cards += card('warn', 'Date / Time', s.dateTime, '');
  if (s.invocationCounter !== undefined) cards += card('', 'Invocation Counter', s.invocationCounter, '0x' + s.invocationCounter.toString(16).toUpperCase().padStart(8,'0'));
  if (s.messageCounter !== undefined) cards += card('', 'Message Counter', s.messageCounter, '0x' + s.messageCounter.toString(16).toUpperCase().padStart(8,'0'));
  if (s.securitySuite) cards += card('', 'Security Suite', s.securitySuite, s.securityPolicy);
  if (s.payloadLength) cards += card('purple', 'Payload Size', `${s.payloadLength} bytes`, s.hasGCMTag ? '+ 12 byte GCM tag' : '');
  if (s.dlmsService) cards += card('info', 'DLMS Service', s.dlmsService, '');
  if (s.macLength) cards += card('error', 'MAC / Signature', `${s.macLength} bytes`, s.hasGCMTag ? 'AES-GCM Tag' : 'ECDSA or GMAC');

  let errHtml = '';
  if (result.errors.length > 0) {
    errHtml = `<div class="parse-error" style="margin-bottom:1rem">âš  ${result.errors.join('<br>')}</div>`;
  }

  sc.innerHTML = `${errHtml}<div class="summary-grid">${cards}</div>`;
}

function hexToBytes(hexStr) {
  const bytes = [];
  for (let i = 0; i < hexStr.length; i += 2) bytes.push(parseInt(hexStr.substr(i, 2), 16));
  return bytes;
}

function renderTree(result, bytes) {
  document.getElementById('emptyTree').style.display = 'none';
  const tc = document.getElementById('treeContent');

  // Group fields by category
  const categoryNames = {
    'c-header':   'GBT Frame Header',
    'c-general':  'General Header',
    'c-routing':  'Routing / Addresses',
    'c-date':     'Date & Time',
    'c-counter':  'Counters',
    'c-security': 'Security Control',
    'c-ciphered': 'Ciphered Data',
    'c-payload':  'Payload / DLMS Data',
    'c-mac':      'MAC / Signature',
    'c-dlms':     'DLMS Service',
    'c-tag':      'Tags & Types',
    'c-length':   'Lengths',
  };

  const groups = {};
  const order = [];
  for (const f of result.fields) {
    if (!groups[f.category]) { groups[f.category] = []; order.push(f.category); }
    groups[f.category].push(f);
  }

  let html = '';
  for (const cat of order) {
    const fields = groups[cat];
    const catName = categoryNames[cat] || cat;
    const totalLen = fields.reduce((s, f) => s + f.len, 0);
    const gid = 'grp_' + cat;
    html += `
      <div class="tree-node">
        <div class="tree-row clickable ${cat}" style="cursor:pointer" onclick="toggleGroup('${gid}')">
          <div class="tree-indent"><span class="tree-toggle" id="${gid}_icon">â–¼</span></div>
          <div class="tree-tag">${catName}</div>
          <div class="tree-desc">${fields.length} field(s)</div>
          <div class="tree-hex"></div>
          <div class="tree-len">${totalLen}B</div>
        </div>
        <div class="tree-children child-indent" id="${gid}">`;

    for (const f of fields) {
      const hexShort = f.hexVal.length > 24 ? f.hexVal.slice(0, 24) + 'â€¦' : f.hexVal;
      const valStr = String(f.parsedVal).length > 50 ? String(f.parsedVal).slice(0, 50) + 'â€¦' : String(f.parsedVal);
      html += `
          <div class="tree-node">
            <div class="tree-row" title="${f.description}">
              <div class="tree-indent"></div>
              <div class="tree-tag ${cat}" style="font-weight:500">${f.name}</div>
              <div class="tree-desc">${escHtml(valStr)}</div>
              <div class="tree-hex">${hexShort}</div>
              <div class="tree-len">+${f.start} [${f.len}]</div>
            </div>
          </div>`;
    }
    html += `</div></div>`;
  }

  tc.innerHTML = html || '<div style="color:var(--text-dim);font-family:var(--font-mono);font-size:0.8rem">No fields parsed</div>';
}

function toggleGroup(id) {
  const el = document.getElementById(id);
  const icon = document.getElementById(id + '_icon');
  if (!el) return;
  const collapsed = el.classList.toggle('collapsed');
  if (icon) icon.textContent = collapsed ? 'â–¶' : 'â–¼';
}

function renderTable(result) {
  document.getElementById('emptyTable').style.display = 'none';
  document.getElementById('tableContent').style.display = 'block';
  const tbody = document.getElementById('tableBody');
  tbody.innerHTML = result.fields.map(f => `
    <tr>
      <td class="field-name">${escHtml(f.name)}</td>
      <td class="field-value">${escHtml(String(f.parsedVal))}</td>
      <td class="field-hex">${f.hexVal.length > 32 ? f.hexVal.slice(0,32)+'â€¦' : f.hexVal}</td>
      <td class="field-type">${f.type}</td>
      <td style="color:var(--text-dim)">${f.start}</td>
      <td style="color:var(--text-dim)">${f.len}</td>
    </tr>
  `).join('');
}

function renderHexDump(bytes, fields) {
  document.getElementById('emptyHex').style.display = 'none';

  // Build offset â†’ field map
  const byteColors = new Array(bytes.length).fill('');
  for (const f of fields) {
    for (let i = f.start; i < f.start + f.len && i < bytes.length; i++) {
      byteColors[i] = f.category;
    }
  }

  const WIDTH = 16;
  let html = '';
  for (let row = 0; row < bytes.length; row += WIDTH) {
    const rowBytes = bytes.slice(row, row + WIDTH);
    let hexPart = '';
    let asciiPart = '';
    for (let col = 0; col < rowBytes.length; col++) {
      const b = rowBytes[col];
      const abs = row + col;
      const cls = byteColors[abs] || '';
      hexPart += `<span class="hex-byte ${cls}" title="offset ${abs}">${toHex(b)}</span>`;
      const ch = (b >= 32 && b < 127) ? String.fromCharCode(b) : 'Â·';
      asciiPart += ch;
    }
    html += `<div class="hex-row">
      <div class="hex-offset">${row.toString(16).padStart(4,'0')}</div>
      <div class="hex-bytes">${hexPart}</div>
      <div class="hex-ascii">${asciiPart}</div>
    </div>`;
  }
  document.getElementById('hexContent').innerHTML = html;
}

function showTab(name) {
  document.querySelectorAll('.tab').forEach((t, i) => t.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  const tabs = ['summary','tree','table','hex'];
  const idx = tabs.indexOf(name);
  document.querySelectorAll('.tab')[idx].classList.add('active');
  document.getElementById('tab-' + name).classList.add('active');
}

function clearAll() {
  document.getElementById('inputHex').value = '';
  parsedResult = null;
  const badge = document.getElementById('statusBadge');
  badge.className = 'status-badge';
  badge.textContent = '';
  ['Summary','Tree','Table','Hex'].forEach(n => {
    const empty = document.getElementById('empty' + n);
    if (empty) empty.style.display = 'flex';
  });
  document.getElementById('summaryContent').style.display = 'none';
  document.getElementById('tableContent').style.display = 'none';
  document.getElementById('treeContent').innerHTML = '';
  document.getElementById('hexContent').innerHTML = '';
}

function escHtml(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

// Keyboard shortcut
document.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') parseGBCS();
});

// Init
populateExamples();
</script>
</body>
</html>
